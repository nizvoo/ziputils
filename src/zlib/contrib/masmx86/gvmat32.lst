Microsoft (R) Macro Assembler Version 6.14.8444		    12/27/09 07:12:50
gvmat32.asm						     Page 1 - 1


				; gvmat32.asm -- Asm portion of the optimized longest_match for 32 bits x86
				; Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.
				; File written by Gilles Vollant, by modifiying the longest_match
				;  from Jean-loup Gailly in deflate.c
				;
				;         http://www.zlib.net
				;         http://www.winimage.com/zLibDll
				;         http://www.muppetlabs.com/~breadbox/software/assembly.html
				;
				; For Visual C++ 4.x and higher and ML 6.x and higher
				;   ml.exe is in directory \MASM611C of Win95 DDK
				;   ml.exe is also distributed in http://www.masm32.com/masmdl.htm
				;    and in VC++2003 toolkit at http://msdn.microsoft.com/visualc/vctoolkit2003/
				;
				; this file contain two implementation of longest_match
				;
				;  longest_match_7fff : written 1996 by Gilles Vollant optimized for 
				;            first Pentium. Assume s->w_mask == 0x7fff
				;  longest_match_686 : written by Brian raiter (1998), optimized for Pentium Pro
				;
				;  for using an seembly version of longest_match, you need define ASMV in project
				;  There is two way in using gvmat32.asm
				;
				;  A) Suggested method
				;    if you want include both longest_match_7fff and longest_match_686
				;    compile the asm file running
				;           ml /coff /Zi /Flgvmat32.lst /c gvmat32.asm
				;    and include gvmat32c.c in your project
				;    if you have an old cpu (386,486 or first Pentium) and s->w_mask==0x7fff,
				;        longest_match_7fff will be used
				;    if you have a more modern CPU (Pentium Pro, II and higher)
				;        longest_match_686 will be used
				;    on old cpu with s->w_mask!=0x7fff, longest_match_686 will be used,
				;        but this is not a sitation you'll find often
				;
				;  B) Alternative
				;    if you are not interresed in old cpu performance and want the smaller
				;       binaries possible
				;
				;    compile the asm file running
				;           ml /coff /Zi /c /Flgvmat32.lst /DNOOLDPENTIUMCODE gvmat32.asm
				;    and do not include gvmat32c.c in your project (ou define also 
				;              NOOLDPENTIUMCODE)
				;
				; note : as I known, longest_match_686 is very faster than longest_match_7fff
				;        on pentium Pro/II/III, faster (but less) in P4, but it seem
				;        longest_match_7fff can be faster (very very litte) on AMD Athlon64/K8
				;
				; see below : zlib1222add must be adjuster if you use a zlib version < 1.2.2.2

				;uInt longest_match_7fff(s, cur_match)
				;    deflate_state *s;
				;    IPos cur_match;                             /* current match */

 = 0000004C			    NbStack         equ     76
 = dword ptr[esp+NbStack-0]	    cur_match       equ     dword ptr[esp+NbStack-0]
 = dword ptr[esp+NbStack-4]	    str_s           equ     dword ptr[esp+NbStack-4]
				; 5 dword on top (ret,ebp,esi,edi,ebx)
 = dword ptr[esp+NbStack-8]	    adrret          equ     dword ptr[esp+NbStack-8]
 = dword ptr[esp+NbStack-12	    pushebp         equ     dword ptr[esp+NbStack-12]
   ]
 = dword ptr[esp+NbStack-16	    pushedi         equ     dword ptr[esp+NbStack-16]
   ]
 = dword ptr[esp+NbStack-20	    pushesi         equ     dword ptr[esp+NbStack-20]
   ]
 = dword ptr[esp+NbStack-24	    pushebx         equ     dword ptr[esp+NbStack-24]
   ]

 = dword ptr [esp+NbStack-2	    chain_length    equ     dword ptr [esp+NbStack-28]
   8]
 = dword ptr [esp+NbStack-3	    limit           equ     dword ptr [esp+NbStack-32]
   2]
 = dword ptr [esp+NbStack-3	    best_len        equ     dword ptr [esp+NbStack-36]
   6]
 = dword ptr [esp+NbStack-4	    window          equ     dword ptr [esp+NbStack-40]
   0]
 = dword ptr [esp+NbStack-4	    prev            equ     dword ptr [esp+NbStack-44]
   4]
 = word ptr [esp+NbStack-48	    scan_start      equ      word ptr [esp+NbStack-48]
   ]
 = dword ptr [esp+NbStack-5	    wmask           equ     dword ptr [esp+NbStack-52]
   2]
 = dword ptr [esp+NbStack-5	    match_start_ptr equ     dword ptr [esp+NbStack-56]
   6]
 = dword ptr [esp+NbStack-6	    nice_match      equ     dword ptr [esp+NbStack-60]
   0]
 = dword ptr [esp+NbStack-6	    scan            equ     dword ptr [esp+NbStack-64]
   4]

 = dword ptr [esp+NbStack-6	    windowlen       equ     dword ptr [esp+NbStack-68]
   8]
 = dword ptr [esp+NbStack-7	    match_start     equ     dword ptr [esp+NbStack-72]
   2]
 = dword ptr [esp+NbStack-7	    strend          equ     dword ptr [esp+NbStack-76]
   6]
 = 00000034			    NbStackAdd      equ     (NbStack-24)

				    .386p

				    name    gvmatch
				    .MODEL  FLAT



				;  all the +zlib1222add offsets are due to the addition of fields
				;  in zlib in the deflate_state structure since the asm code was first written
				;  (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
				;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
				;  if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").

 = 00000008			    zlib1222add         equ     8

				;  Note : these value are good with a 8 bytes boundary pack structure
 = 0000007C			    dep_chain_length    equ     74h+zlib1222add
 = 00000038			    dep_window          equ     30h+zlib1222add
 = 0000006C			    dep_strstart        equ     64h+zlib1222add
 = 00000078			    dep_prev_length     equ     70h+zlib1222add
 = 00000090			    dep_nice_match      equ     88h+zlib1222add
 = 0000002C			    dep_w_size          equ     24h+zlib1222add
 = 00000040			    dep_prev            equ     38h+zlib1222add
 = 00000034			    dep_w_mask          equ     2ch+zlib1222add
 = 0000008C			    dep_good_match      equ     84h+zlib1222add
 = 00000070			    dep_match_start     equ     68h+zlib1222add
 = 00000074			    dep_lookahead       equ     6ch+zlib1222add


 00000000			_TEXT                   segment

				IFDEF NOUNDERLINE
				ELSE
				   IFDEF NOOLDPENTIUMCODE
				   ELSE
				            public  _longest_match_7fff
				            public  _cpudetect32
				            public  _longest_match_686
				   ENDIF
				ENDIF

 = 00000102			    MAX_MATCH           equ     258
 = 00000003			    MIN_MATCH           equ     3
 = 00000106			    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)



				IFNDEF NOOLDPENTIUMCODE
				IFDEF NOUNDERLINE
				ELSE
 00000000			_longest_match_7fff  proc near
				ENDIF

 00000000  8B 54 24 04		    mov     edx,[esp+4]



 00000004  55			    push    ebp
 00000005  57			    push    edi
 00000006  56			    push    esi
 00000007  53			    push    ebx

 00000008  83 EC 34		    sub     esp,NbStackAdd

				; initialize or check the variables used in match.asm.
 0000000B  8B EA		    mov     ebp,edx

				; chain_length = s->max_chain_length
				; if (prev_length>=good_match) chain_length >>= 2
 0000000D  8B 55 7C		    mov     edx,[ebp+dep_chain_length]
 00000010  8B 5D 78		    mov     ebx,[ebp+dep_prev_length]
 00000013  39 9D 0000008C	    cmp     [ebp+dep_good_match],ebx
 00000019  77 03		    ja      noshr
 0000001B  C1 EA 02		    shr     edx,2
 0000001E			noshr:
				; we increment chain_length because in the asm, the --chain_lenght is in the beginning of the loop
 0000001E  42			    inc     edx
 0000001F  8B BD 00000090	    mov     edi,[ebp+dep_nice_match]
 00000025  89 54 24 30		    mov     chain_length,edx
 00000029  8B 45 74		    mov     eax,[ebp+dep_lookahead]
 0000002C  3B C7		    cmp     eax,edi
				; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
 0000002E  73 02		    jae     nolookaheadnicematch
 00000030  8B F8		    mov     edi,eax
 00000032			nolookaheadnicematch:
				; best_len = s->prev_length
 00000032  89 5C 24 28		    mov     best_len,ebx

				; window = s->window
 00000036  8B 75 38		    mov     esi,[ebp+dep_window]
 00000039  8B 4D 6C		    mov     ecx,[ebp+dep_strstart]
 0000003C  89 74 24 24		    mov     window,esi

 00000040  89 7C 24 10		    mov     nice_match,edi
				; scan = window + strstart
 00000044  03 F1		    add     esi,ecx
 00000046  89 74 24 0C		    mov     scan,esi
				; dx = *window
 0000004A  66| 8B 16		    mov     dx,word ptr [esi]
				; bx = *(window+best_len-1)
 0000004D  66| 8B 5C 33		    mov     bx,word ptr [esi+ebx-1]
	   FF
 00000052  81 C6 00000101	    add     esi,MAX_MATCH-1
				; scan_start = *scan
 00000058  66| 89 54 24		    mov     scan_start,dx
	   1C
				; strend = scan + MAX_MATCH-1
 0000005D  89 34 24		    mov     strend,esi
				; bx = scan_end = *(window+best_len-1)

				;    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
				;        s->strstart - (IPos)MAX_DIST(s) : NIL;

 00000060  8B 75 2C		    mov     esi,[ebp+dep_w_size]
 00000063  81 EE 00000106	    sub     esi,MIN_LOOKAHEAD
				; here esi = MAX_DIST(s)
 00000069  2B CE		    sub     ecx,esi
 0000006B  77 02		    ja      nodist
 0000006D  33 C9		    xor     ecx,ecx
 0000006F			nodist:
 0000006F  89 4C 24 2C		    mov     limit,ecx

				; prev = s->prev
 00000073  8B 55 40		    mov     edx,[ebp+dep_prev]
 00000076  89 54 24 20		    mov     prev,edx

				;
 0000007A  8B 55 70		    mov     edx,dword ptr [ebp+dep_match_start]
 0000007D  66| 8B 6C 24		    mov     bp,scan_start
	   1C
 00000082  8B 44 24 4C		    mov     eax,cur_match
 00000086  89 54 24 04		    mov     match_start,edx

 0000008A  8B 54 24 24		    mov     edx,window
 0000008E  8B FA		    mov     edi,edx
 00000090  03 7C 24 28		    add     edi,best_len
 00000094  8B 74 24 20		    mov     esi,prev
 00000098  4F			    dec     edi
				; windowlen = window + best_len -1
 00000099  89 7C 24 08		    mov     windowlen,edi

 0000009D  EB 4E		    jmp     beginloop2
				    align   4

				; here, in the loop
				;       eax = ax = cur_match
				;       ecx = limit
				;        bx = scan_end
				;        bp = scan_start
				;       edi = windowlen (window + best_len -1)
				;       esi = prev


				;// here; chain_length <=16
 000000A0			normalbeg0add16:
 000000A0  83 44 24 30 10	    add     chain_length,16
 000000A5  0F 84 000003D1	    jz      exitloop
 000000AB			normalbeg0:
 000000AB  66| 39 1C 38		    cmp     word ptr[edi+eax],bx
 000000AF  74 1C		    je      normalbeg2noroll
 000000B1			rcontlabnoroll:
				; cur_match = prev[cur_match & wmask]
 000000B1  25 00007FFF		    and     eax,7fffh
 000000B6  66| 8B 04 46		    mov     ax,word ptr[esi+eax*2]
				; if cur_match > limit, go to exitloop
 000000BA  3B C8		    cmp     ecx,eax
 000000BC  0F 83 000003BA	    jnb     exitloop
				; if --chain_length != 0, go to exitloop
 000000C2  FF 4C 24 30		    dec     chain_length
 000000C6  75 E3		    jnz     normalbeg0
 000000C8  E9 000003AF		    jmp     exitloop

 000000CD			normalbeg2noroll:
				; if (scan_start==*(cur_match+window)) goto normalbeg2
 000000CD  66| 3B 2C 10		    cmp     bp,word ptr[edx+eax]
 000000D1  75 DE		    jne     rcontlabnoroll
 000000D3  E9 000002E3		    jmp     normalbeg2

 000000D8			contloop3:
 000000D8  8B 7C 24 08		    mov     edi,windowlen

				; cur_match = prev[cur_match & wmask]
 000000DC  25 00007FFF		    and     eax,7fffh
 000000E1  66| 8B 04 46		    mov     ax,word ptr[esi+eax*2]
				; if cur_match > limit, go to exitloop
 000000E5  3B C8		    cmp     ecx,eax
 000000E7			jnbexitloopshort1:
 000000E7  0F 83 0000038F	    jnb     exitloop
				; if --chain_length != 0, go to exitloop


				; begin the main loop
 000000ED			beginloop2:
 000000ED  83 6C 24 30 11	    sub     chain_length,16+1
				; if chain_length <=16, don't use the unrolled loop
 000000F2  76 AC		    jna     normalbeg0add16

 000000F4			do16:
 000000F4  66| 39 1C 38		    cmp     word ptr[edi+eax],bx
 000000F8  0F 84 000002AC	    je      normalbeg2dc0

				maccn   MACRO   lab
				    and     eax,7fffh
				    mov     ax,word ptr[esi+eax*2]
				    cmp     ecx,eax
				    jnb     exitloop
				    cmp     word ptr[edi+eax],bx
				    je      lab
				    ENDM

 000000FE			rcontloop0:
				    maccn   normalbeg2dc1
 000000FE  25 00007FFF	     1	    and     eax,7fffh
 00000103  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 00000107  3B C8	     1	    cmp     ecx,eax
 00000109  0F 83 0000036D    1	    jnb     exitloop
 0000010F  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 00000113  0F 84 00000280    1	    je      normalbeg2dc1

 00000119			rcontloop1:
				    maccn   normalbeg2dc2
 00000119  25 00007FFF	     1	    and     eax,7fffh
 0000011E  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 00000122  3B C8	     1	    cmp     ecx,eax
 00000124  0F 83 00000352    1	    jnb     exitloop
 0000012A  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 0000012E  0F 84 00000254    1	    je      normalbeg2dc2

 00000134			rcontloop2:
				    maccn   normalbeg2dc3
 00000134  25 00007FFF	     1	    and     eax,7fffh
 00000139  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 0000013D  3B C8	     1	    cmp     ecx,eax
 0000013F  0F 83 00000337    1	    jnb     exitloop
 00000145  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 00000149  0F 84 00000228    1	    je      normalbeg2dc3

 0000014F			rcontloop3:
				    maccn   normalbeg2dc4
 0000014F  25 00007FFF	     1	    and     eax,7fffh
 00000154  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 00000158  3B C8	     1	    cmp     ecx,eax
 0000015A  0F 83 0000031C    1	    jnb     exitloop
 00000160  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 00000164  0F 84 000001FC    1	    je      normalbeg2dc4

 0000016A			rcontloop4:
				    maccn   normalbeg2dc5
 0000016A  25 00007FFF	     1	    and     eax,7fffh
 0000016F  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 00000173  3B C8	     1	    cmp     ecx,eax
 00000175  0F 83 00000301    1	    jnb     exitloop
 0000017B  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 0000017F  0F 84 000001D0    1	    je      normalbeg2dc5

 00000185			rcontloop5:
				    maccn   normalbeg2dc6
 00000185  25 00007FFF	     1	    and     eax,7fffh
 0000018A  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 0000018E  3B C8	     1	    cmp     ecx,eax
 00000190  0F 83 000002E6    1	    jnb     exitloop
 00000196  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 0000019A  0F 84 000001A4    1	    je      normalbeg2dc6

 000001A0			rcontloop6:
				    maccn   normalbeg2dc7
 000001A0  25 00007FFF	     1	    and     eax,7fffh
 000001A5  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 000001A9  3B C8	     1	    cmp     ecx,eax
 000001AB  0F 83 000002CB    1	    jnb     exitloop
 000001B1  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 000001B5  0F 84 00000175    1	    je      normalbeg2dc7

 000001BB			rcontloop7:
				    maccn   normalbeg2dc8
 000001BB  25 00007FFF	     1	    and     eax,7fffh
 000001C0  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 000001C4  3B C8	     1	    cmp     ecx,eax
 000001C6  0F 83 000002B0    1	    jnb     exitloop
 000001CC  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 000001D0  0F 84 00000146    1	    je      normalbeg2dc8

 000001D6			rcontloop8:
				    maccn   normalbeg2dc9
 000001D6  25 00007FFF	     1	    and     eax,7fffh
 000001DB  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 000001DF  3B C8	     1	    cmp     ecx,eax
 000001E1  0F 83 00000295    1	    jnb     exitloop
 000001E7  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 000001EB  0F 84 00000117    1	    je      normalbeg2dc9

 000001F1			rcontloop9:
				    maccn   normalbeg2dc10
 000001F1  25 00007FFF	     1	    and     eax,7fffh
 000001F6  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 000001FA  3B C8	     1	    cmp     ecx,eax
 000001FC  0F 83 0000027A    1	    jnb     exitloop
 00000202  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 00000206  0F 84 000000E8    1	    je      normalbeg2dc10

 0000020C			rcontloop10:
				    maccn   short normalbeg2dc11
 0000020C  25 00007FFF	     1	    and     eax,7fffh
 00000211  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 00000215  3B C8	     1	    cmp     ecx,eax
 00000217  0F 83 0000025F    1	    jnb     exitloop
 0000021D  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 00000221  74 7D	     1	    je      short normalbeg2dc11

 00000223			rcontloop11:
				    maccn   short normalbeg2dc12
 00000223  25 00007FFF	     1	    and     eax,7fffh
 00000228  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 0000022C  3B C8	     1	    cmp     ecx,eax
 0000022E  0F 83 00000248    1	    jnb     exitloop
 00000234  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 00000238  74 7A	     1	    je      short normalbeg2dc12

 0000023A			rcontloop12:
				    maccn   short normalbeg2dc13
 0000023A  25 00007FFF	     1	    and     eax,7fffh
 0000023F  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 00000243  3B C8	     1	    cmp     ecx,eax
 00000245  0F 83 00000231    1	    jnb     exitloop
 0000024B  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 0000024F  74 73	     1	    je      short normalbeg2dc13

 00000251			rcontloop13:
				    maccn   short normalbeg2dc14
 00000251  25 00007FFF	     1	    and     eax,7fffh
 00000256  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 0000025A  3B C8	     1	    cmp     ecx,eax
 0000025C  0F 83 0000021A    1	    jnb     exitloop
 00000262  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 00000266  74 6C	     1	    je      short normalbeg2dc14

 00000268			rcontloop14:
				    maccn   short normalbeg2dc15
 00000268  25 00007FFF	     1	    and     eax,7fffh
 0000026D  66| 8B 04 46	     1	    mov     ax,word ptr[esi+eax*2]
 00000271  3B C8	     1	    cmp     ecx,eax
 00000273  0F 83 00000203    1	    jnb     exitloop
 00000279  66| 39 1C 38	     1	    cmp     word ptr[edi+eax],bx
 0000027D  74 65	     1	    je      short normalbeg2dc15

 0000027F			rcontloop15:
 0000027F  25 00007FFF		    and     eax,7fffh
 00000284  66| 8B 04 46		    mov     ax,word ptr[esi+eax*2]
 00000288  3B C8		    cmp     ecx,eax
 0000028A  0F 83 000001EC	    jnb     exitloop

 00000290  83 6C 24 30 10	    sub     chain_length,16
 00000295  0F 87 FFFFFE59	    ja      do16
 0000029B  E9 FFFFFE00		    jmp     normalbeg0add16

				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

				normbeg MACRO   rcontlab,valsub
				; if we are here, we know that *(match+best_len-1) == scan_end
				    cmp     bp,word ptr[edx+eax]
				; if (match != scan_start) goto rcontlab
				    jne     rcontlab
				; calculate the good chain_length, and we'll compare scan and match string
				    add     chain_length,16-valsub
				    jmp     iseq
				    ENDM


 000002A0			normalbeg2dc11:
				    normbeg rcontloop11,11
 000002A0  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 000002A4  0F 85 FFFFFF79    1	    jne     rcontloop11
 000002AA  83 44 24 30 05    1	    add     chain_length,16-11
 000002AF  E9 00000115	     1	    jmp     iseq

 000002B4			normalbeg2dc12:
				    normbeg short rcontloop12,12
 000002B4  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 000002B8  75 80	     1	    jne     short rcontloop12
 000002BA  83 44 24 30 04    1	    add     chain_length,16-12
 000002BF  E9 00000105	     1	    jmp     iseq

 000002C4			normalbeg2dc13:
				    normbeg short rcontloop13,13
 000002C4  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 000002C8  75 87	     1	    jne     short rcontloop13
 000002CA  83 44 24 30 03    1	    add     chain_length,16-13
 000002CF  E9 000000F5	     1	    jmp     iseq

 000002D4			normalbeg2dc14:
				    normbeg short rcontloop14,14
 000002D4  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 000002D8  75 8E	     1	    jne     short rcontloop14
 000002DA  83 44 24 30 02    1	    add     chain_length,16-14
 000002DF  E9 000000E5	     1	    jmp     iseq

 000002E4			normalbeg2dc15:
				    normbeg short rcontloop15,15
 000002E4  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 000002E8  75 95	     1	    jne     short rcontloop15
 000002EA  83 44 24 30 01    1	    add     chain_length,16-15
 000002EF  E9 000000D5	     1	    jmp     iseq

 000002F4			normalbeg2dc10:
				    normbeg rcontloop10,10
 000002F4  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 000002F8  0F 85 FFFFFF0E    1	    jne     rcontloop10
 000002FE  83 44 24 30 06    1	    add     chain_length,16-10
 00000303  E9 000000C1	     1	    jmp     iseq

 00000308			normalbeg2dc9:
				    normbeg rcontloop9,9
 00000308  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 0000030C  0F 85 FFFFFEDF    1	    jne     rcontloop9
 00000312  83 44 24 30 07    1	    add     chain_length,16-9
 00000317  E9 000000AD	     1	    jmp     iseq

 0000031C			normalbeg2dc8:
				    normbeg rcontloop8,8
 0000031C  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 00000320  0F 85 FFFFFEB0    1	    jne     rcontloop8
 00000326  83 44 24 30 08    1	    add     chain_length,16-8
 0000032B  E9 00000099	     1	    jmp     iseq

 00000330			normalbeg2dc7:
				    normbeg rcontloop7,7
 00000330  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 00000334  0F 85 FFFFFE81    1	    jne     rcontloop7
 0000033A  83 44 24 30 09    1	    add     chain_length,16-7
 0000033F  E9 00000085	     1	    jmp     iseq

 00000344			normalbeg2dc6:
				    normbeg rcontloop6,6
 00000344  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 00000348  0F 85 FFFFFE52    1	    jne     rcontloop6
 0000034E  83 44 24 30 0A    1	    add     chain_length,16-6
 00000353  EB 74	     1	    jmp     iseq

 00000355			normalbeg2dc5:
				    normbeg rcontloop5,5
 00000355  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 00000359  0F 85 FFFFFE26    1	    jne     rcontloop5
 0000035F  83 44 24 30 0B    1	    add     chain_length,16-5
 00000364  EB 63	     1	    jmp     iseq

 00000366			normalbeg2dc4:
				    normbeg rcontloop4,4
 00000366  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 0000036A  0F 85 FFFFFDFA    1	    jne     rcontloop4
 00000370  83 44 24 30 0C    1	    add     chain_length,16-4
 00000375  EB 52	     1	    jmp     iseq

 00000377			normalbeg2dc3:
				    normbeg rcontloop3,3
 00000377  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 0000037B  0F 85 FFFFFDCE    1	    jne     rcontloop3
 00000381  83 44 24 30 0D    1	    add     chain_length,16-3
 00000386  EB 41	     1	    jmp     iseq

 00000388			normalbeg2dc2:
				    normbeg rcontloop2,2
 00000388  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 0000038C  0F 85 FFFFFDA2    1	    jne     rcontloop2
 00000392  83 44 24 30 0E    1	    add     chain_length,16-2
 00000397  EB 30	     1	    jmp     iseq

 00000399			normalbeg2dc1:
				    normbeg rcontloop1,1
 00000399  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 0000039D  0F 85 FFFFFD76    1	    jne     rcontloop1
 000003A3  83 44 24 30 0F    1	    add     chain_length,16-1
 000003A8  EB 1F	     1	    jmp     iseq

 000003AA			normalbeg2dc0:
				    normbeg rcontloop0,0
 000003AA  66| 3B 2C 10	     1	    cmp     bp,word ptr[edx+eax]
 000003AE  0F 85 FFFFFD4A    1	    jne     rcontloop0
 000003B4  83 44 24 30 10    1	    add     chain_length,16-0
 000003B9  EB 0E	     1	    jmp     iseq


				; we go in normalbeg2 because *(ushf*)(match+best_len-1) == scan_end

 000003BB			normalbeg2:
 000003BB  8B 7C 24 24		    mov     edi,window

 000003BF  66| 3B 2C 38		    cmp     bp,word ptr[edi+eax]
 000003C3  0F 85 FFFFFD0F	    jne     contloop3                   ; if *(ushf*)match != scan_start, continue

 000003C9			iseq:
				; if we are here, we know that *(match+best_len-1) == scan_end
				; and (match == scan_start)

 000003C9  8B FA		    mov     edi,edx
 000003CB  8B 74 24 0C		    mov     esi,scan                    ; esi = scan
 000003CF  03 F8		    add     edi,eax                     ; edi = window + cur_match = match

 000003D1  8B 56 03		    mov     edx,[esi+3]                 ; compare manually dword at match+3
 000003D4  33 57 03		    xor     edx,[edi+3]                 ; and scan +3

 000003D7  74 2D		    jz      begincompare                ; if equal, go to long compare

				; we will determine the unmatch byte and calculate len (in esi)
 000003D9  0A D2		    or      dl,dl
 000003DB  74 07		    je      eq1rr
 000003DD  BE 00000003		    mov     esi,3
 000003E2  EB 51		    jmp     trfinval
 000003E4			eq1rr:
 000003E4  66| 0B D2		    or      dx,dx
 000003E7  74 07		    je      eq1

 000003E9  BE 00000004		    mov     esi,4
 000003EE  EB 45		    jmp     trfinval
 000003F0			eq1:
 000003F0  81 E2 00FFFFFF	    and     edx,0ffffffh
 000003F6  74 07		    jz      eq11
 000003F8  BE 00000005		    mov     esi,5
 000003FD  EB 36		    jmp     trfinval
 000003FF			eq11:
 000003FF  BE 00000006		    mov     esi,6
 00000404  EB 2F		    jmp     trfinval

 00000406			begincompare:
				    ; here we now scan and match begin same
 00000406  83 C7 06		    add     edi,6
 00000409  83 C6 06		    add     esi,6
 0000040C  B9 0000003F		    mov     ecx,(MAX_MATCH-(2+4))/4     ; scan for at most MAX_MATCH bytes
 00000411  F3/ A7		    repe    cmpsd                       ; loop until mismatch

 00000413  74 1C		    je      trfin                       ; go to trfin if not unmatch
				; we determine the unmatch byte
 00000415  83 EE 04		    sub     esi,4
 00000418  8B 57 FC		    mov     edx,[edi-4]
 0000041B  33 16		    xor     edx,[esi]

 0000041D  0A D2		    or      dl,dl
 0000041F  75 10		    jnz     trfin
 00000421  46			    inc     esi

 00000422  66| 0B D2		    or      dx,dx
 00000425  75 0A		    jnz     trfin
 00000427  46			    inc     esi

 00000428  81 E2 00FFFFFF	    and     edx,0ffffffh
 0000042E  75 01		    jnz     trfin
 00000430  46			    inc     esi

 00000431			trfin:
 00000431  2B 74 24 0C		    sub     esi,scan          ; esi = len
 00000435			trfinval:
				; here we have finised compare, and esi contain len of equal string
 00000435  3B 74 24 28		    cmp     esi,best_len        ; if len > best_len, go newbestlen
 00000439  77 11		    ja      short newbestlen
				; now we restore edx, ecx and esi, for the big loop
 0000043B  8B 74 24 20		    mov     esi,prev
 0000043F  8B 4C 24 2C		    mov     ecx,limit
 00000443  8B 54 24 24		    mov     edx,window
 00000447  E9 FFFFFC8C		    jmp     contloop3

 0000044C			newbestlen:
 0000044C  89 74 24 28		    mov     best_len,esi        ; len become best_len

 00000450  89 44 24 04		    mov     match_start,eax     ; save new position as match_start
 00000454  3B 74 24 10		    cmp     esi,nice_match      ; if best_len >= nice_match, exit
 00000458  73 22		    jae     exitloop
 0000045A  8B 4C 24 0C		    mov     ecx,scan
 0000045E  8B 54 24 24		    mov     edx,window          ; restore edx=window
 00000462  03 CE		    add     ecx,esi
 00000464  03 F2		    add     esi,edx

 00000466  4E			    dec     esi
 00000467  89 74 24 08		    mov     windowlen,esi       ; windowlen = window + best_len-1
 0000046B  66| 8B 59 FF		    mov     bx,[ecx-1]          ; bx = *(scan+best_len-1) = scan_end

				; now we restore ecx and esi, for the big loop :
 0000046F  8B 74 24 20		    mov     esi,prev
 00000473  8B 4C 24 2C		    mov     ecx,limit
 00000477  E9 FFFFFC5C		    jmp     contloop3

 0000047C			exitloop:
				; exit : s->match_start=match_start
 0000047C  8B 5C 24 04		    mov     ebx,match_start
 00000480  8B 6C 24 48		    mov     ebp,str_s
 00000484  8B 4C 24 28		    mov     ecx,best_len
 00000488  89 5D 70		    mov     dword ptr [ebp+dep_match_start],ebx
 0000048B  8B 45 74		    mov     eax,dword ptr [ebp+dep_lookahead]
 0000048E  3B C8		    cmp     ecx,eax
 00000490  77 02		    ja      minexlo
 00000492  8B C1		    mov     eax,ecx
 00000494			minexlo:
				; return min(best_len,s->lookahead)

				; restore stack and register ebx,esi,edi,ebp
 00000494  83 C4 34		    add     esp,NbStackAdd

 00000497  5B			    pop     ebx
 00000498  5E			    pop     esi
 00000499  5F			    pop     edi
 0000049A  5D			    pop     ebp
 0000049B  C3			    ret
 0000049C			InfoAuthor:
				; please don't remove this string !
				; Your are free use gvmat32 in any fre or commercial apps if you don't remove the string in the binary!
 0000049C  0D 0A 47 56 4D	    db     0dh,0ah,"GVMat32 optimised assembly code written 1996-98 by Gilles Vollant",0dh,0ah
	   61 74 33 32 20
	   6F 70 74 69 6D
	   69 73 65 64 20
	   61 73 73 65 6D
	   62 6C 79 20 63
	   6F 64 65 20 77
	   72 69 74 74 65
	   6E 20 31 39 39
	   36 2D 39 38 20
	   62 79 20 47 69
	   6C 6C 65 73 20
	   56 6F 6C 6C 61
	   6E 74 0D 0A



				IFDEF NOUNDERLINE
				ELSE
 000004E1			_longest_match_7fff  endp
				ENDIF


				IFDEF NOUNDERLINE
				ELSE
 000004E1			_cpudetect32    proc near
				ENDIF

 000004E1  53			    push    ebx

 000004E2  9C			    pushfd                  ; push original EFLAGS
 000004E3  58			    pop     eax             ; get original EFLAGS
 000004E4  8B C8		    mov     ecx, eax        ; save original EFLAGS
 000004E6  35 00040000		    xor     eax, 40000h     ; flip AC bit in EFLAGS
 000004EB  50			    push    eax             ; save new EFLAGS value on stack
 000004EC  9D			    popfd                   ; replace current EFLAGS value
 000004ED  9C			    pushfd                  ; get new EFLAGS
 000004EE  58			    pop     eax             ; store new EFLAGS in EAX
 000004EF  33 C1		    xor     eax, ecx        ; can’t toggle AC bit, processor=80386
 000004F1  74 1E		    jz      end_cpu_is_386  ; jump if 80386 processor
 000004F3  51			    push    ecx
 000004F4  9D			    popfd                   ; restore AC bit in EFLAGS first

 000004F5  9C			    pushfd
 000004F6  9C			    pushfd
 000004F7  59			    pop     ecx

 000004F8  8B C1		    mov     eax, ecx        ; get original EFLAGS
 000004FA  35 00200000		    xor     eax, 200000h    ; flip ID bit in EFLAGS
 000004FF  50			    push    eax             ; save new EFLAGS value on stack
 00000500  9D			    popfd                   ; replace current EFLAGS value
 00000501  9C			    pushfd                  ; get new EFLAGS
 00000502  58			    pop     eax             ; store new EFLAGS in EAX
 00000503  9D			    popfd                   ; restore original EFLAGS
 00000504  33 C1		    xor     eax, ecx        ; can’t toggle ID bit,
 00000506  74 10		    je      is_old_486      ; processor=old

 00000508  B8 00000001		    mov     eax,1
 0000050D  0F A2		    db      0fh,0a2h        ;CPUID

 0000050F			exitcpudetect:
 0000050F  5B			    pop ebx
 00000510  C3			    ret

 00000511			end_cpu_is_386:
 00000511  B8 00000300		    mov     eax,0300h
 00000516  EB F7		    jmp     exitcpudetect

 00000518			is_old_486:
 00000518  B8 00000400		    mov     eax,0400h
 0000051D  EB F0		    jmp     exitcpudetect

				IFDEF NOUNDERLINE
				ELSE
 0000051F			_cpudetect32    endp
				ENDIF
				ENDIF

 = 00000102			MAX_MATCH       equ     258
 = 00000003			MIN_MATCH       equ     3
 = 00000106			MIN_LOOKAHEAD   equ     (MAX_MATCH + MIN_MATCH + 1)
 = 00000100			MAX_MATCH_8_     equ     ((MAX_MATCH + 7) AND 0FFF0h)


				;;; stack frame offsets

 = esp + 0			chainlenwmask   equ  esp + 0    ; high word: current chain len
				                    ; low word: s->wmask
 = esp + 4			window      equ  esp + 4    ; local copy of s->window
 = esp + 8			windowbestlen   equ  esp + 8    ; s->window + bestlen
 = esp + 16			scanstart   equ  esp + 16   ; first two bytes of string
 = esp + 12			scanend     equ  esp + 12   ; last two bytes of string
 = esp + 20			scanalign   equ  esp + 20   ; dword-misalignment of string
 = esp + 24			nicematch   equ  esp + 24   ; a good enough match size
 = esp + 28			bestlen     equ  esp + 28   ; size of best match so far
 = esp + 32			scan        equ  esp + 32   ; ptr to string wanting match

 = 00000024			LocalVarsSize   equ 36
				;   saved ebx   byte esp + 36
				;   saved edi   byte esp + 40
				;   saved esi   byte esp + 44
				;   saved ebp   byte esp + 48
				;   return address  byte esp + 52
 = esp + 56			deflatestate    equ  esp + 56   ; the function arguments
 = esp + 60			curmatch    equ  esp + 60

				;;; Offsets for fields in the deflate_state structure. These numbers
				;;; are calculated from the definition of deflate_state, with the
				;;; assumption that the compiler will dword-align the fields. (Thus,
				;;; changing the definition of deflate_state could easily cause this
				;;; program to crash horribly, without so much as a warning at
				;;; compile time. Sigh.)

 = 0000002C			dsWSize     equ 36+zlib1222add
 = 00000034			dsWMask     equ 44+zlib1222add
 = 00000038			dsWindow    equ 48+zlib1222add
 = 00000040			dsPrev      equ 56+zlib1222add
 = 00000060			dsMatchLen  equ 88+zlib1222add
 = 00000064			dsPrevMatch equ 92+zlib1222add
 = 0000006C			dsStrStart  equ 100+zlib1222add
 = 00000070			dsMatchStart    equ 104+zlib1222add
 = 00000074			dsLookahead equ 108+zlib1222add
 = 00000078			dsPrevLen   equ 112+zlib1222add
 = 0000007C			dsMaxChainLen   equ 116+zlib1222add
 = 0000008C			dsGoodMatch equ 132+zlib1222add
 = 00000090			dsNiceMatch equ 136+zlib1222add


				;;; match.asm -- Pentium-Pro-optimized version of longest_match()
				;;; Written for zlib 1.1.2
				;;; Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>
				;;; You can look at http://www.muppetlabs.com/~breadbox/software/assembly.html
				;;;
				;;; This is free software; you can redistribute it and/or modify it
				;;; under the terms of the GNU General Public License.

				;GLOBAL _longest_match, _match_init


				;SECTION    .text

				;;; uInt longest_match(deflate_state *deflatestate, IPos curmatch)

				;_longest_match:
				IFDEF NOOLDPENTIUMCODE
				ELSE
				    IFDEF NOUNDERLINE
				    ELSE
 0000051F			    _longest_match_686  proc near
				    ENDIF
				ENDIF

				;;; Save registers that the compiler may be using, and adjust esp to
				;;; make room for our stack frame.

 0000051F  55			        push    ebp
 00000520  57			        push    edi
 00000521  56			        push    esi
 00000522  53			        push    ebx
 00000523  83 EC 24		        sub esp, LocalVarsSize

				;;; Retrieve the function arguments. ecx will hold cur_match
				;;; throughout the entire function. edx will hold the pointer to the
				;;; deflate_state structure during the function's setup (before
				;;; entering the main loop.

 00000526  8B 54 24 38		        mov edx, [deflatestate]
 0000052A  8B 4C 24 3C		        mov ecx, [curmatch]

				;;; uInt wmask = s->w_mask;
				;;; unsigned chain_length = s->max_chain_length;
				;;; if (s->prev_length >= s->good_match) {
				;;;     chain_length >>= 2;
				;;; }

 0000052E  8B 42 78		        mov eax, [edx + dsPrevLen]
 00000531  8B 9A 0000008C	        mov ebx, [edx + dsGoodMatch]
 00000537  3B C3		        cmp eax, ebx
 00000539  8B 42 34		        mov eax, [edx + dsWMask]
 0000053C  8B 5A 7C		        mov ebx, [edx + dsMaxChainLen]
 0000053F  7C 03		        jl  LastMatchGood
 00000541  C1 EB 02		        shr ebx, 2
 00000544			LastMatchGood:

				;;; chainlen is decremented once beforehand so that the function can
				;;; use the sign flag instead of the zero flag for the exit test.
				;;; It is then shifted into the high word, to make room for the wmask
				;;; value, which it will always accompany.

 00000544  4B			        dec ebx
 00000545  C1 E3 10		        shl ebx, 16
 00000548  0B D8		        or  ebx, eax
 0000054A  89 1C 24		        mov [chainlenwmask], ebx

				;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

 0000054D  8B 82 00000090	        mov eax, [edx + dsNiceMatch]
 00000553  8B 5A 74		        mov ebx, [edx + dsLookahead]
 00000556  3B D8		        cmp ebx, eax
 00000558  7C 02		        jl  LookaheadLess
 0000055A  8B D8		        mov ebx, eax
 0000055C  89 5C 24 18		LookaheadLess:  mov [nicematch], ebx

				;;; register Bytef *scan = s->window + s->strstart;

 00000560  8B 72 38		        mov esi, [edx + dsWindow]
 00000563  89 74 24 04		        mov [window], esi
 00000567  8B 6A 6C		        mov ebp, [edx + dsStrStart]
 0000056A  8D 7C 35 00		        lea edi, [esi + ebp]
 0000056E  89 7C 24 20		        mov [scan], edi

				;;; Determine how many bytes the scan ptr is off from being
				;;; dword-aligned.

 00000572  8B C7		        mov eax, edi
 00000574  F7 D8		        neg eax
 00000576  83 E0 03		        and eax, 3
 00000579  89 44 24 14		        mov [scanalign], eax

				;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
				;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;

 0000057D  8B 42 2C		        mov eax, [edx + dsWSize]
 00000580  2D 00000106		        sub eax, MIN_LOOKAHEAD
 00000585  2B E8		        sub ebp, eax
 00000587  7F 02		        jg  LimitPositive
 00000589  33 ED		        xor ebp, ebp
 0000058B			LimitPositive:

				;;; int best_len = s->prev_length;

 0000058B  8B 42 78		        mov eax, [edx + dsPrevLen]
 0000058E  89 44 24 1C		        mov [bestlen], eax

				;;; Store the sum of s->window + best_len in esi locally, and in esi.

 00000592  03 F0		        add esi, eax
 00000594  89 74 24 08		        mov [windowbestlen], esi

				;;; register ush scan_start = *(ushf*)scan;
				;;; register ush scan_end   = *(ushf*)(scan+best_len-1);
				;;; Posf *prev = s->prev;

 00000598  0F B7 1F		        movzx   ebx, word ptr [edi]
 0000059B  89 5C 24 10		        mov [scanstart], ebx
 0000059F  0F B7 5C 38 FF	        movzx   ebx, word ptr [edi + eax - 1]
 000005A4  89 5C 24 0C		        mov [scanend], ebx
 000005A8  8B 7A 40		        mov edi, [edx + dsPrev]

				;;; Jump into the main loop.

 000005AB  8B 14 24		        mov edx, [chainlenwmask]
 000005AE  EB 1A		        jmp short LoopEntry

				align 4

				;;; do {
				;;;     match = s->window + cur_match;
				;;;     if (*(ushf*)(match+best_len-1) != scan_end ||
				;;;         *(ushf*)match != scan_start) continue;
				;;;     [...]
				;;; } while ((cur_match = prev[cur_match & wmask]) > limit
				;;;          && --chain_length != 0);
				;;;
				;;; Here is the inner loop of the function. The function will spend the
				;;; majority of its time in this loop, and majority of that time will
				;;; be spent in the first ten instructions.
				;;;
				;;; Within this loop:
				;;; ebx = scanend
				;;; ecx = curmatch
				;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
				;;; esi = windowbestlen - i.e., (window + bestlen)
				;;; edi = prev
				;;; ebp = limit

 000005B0			LookupLoop:
 000005B0  23 CA		        and ecx, edx
 000005B2  0F B7 0C 4F		        movzx   ecx, word ptr [edi + ecx*2]
 000005B6  3B CD		        cmp ecx, ebp
 000005B8  0F 86 000000E0	        jbe LeaveNow
 000005BE  81 EA 00010000	        sub edx, 00010000h
 000005C4  0F 88 000000D4	        js  LeaveNow
 000005CA  0F B7 44 31 FF	LoopEntry:  movzx   eax, word ptr [esi + ecx - 1]
 000005CF  3B C3		        cmp eax, ebx
 000005D1  75 DD		        jnz LookupLoop
 000005D3  8B 44 24 04		        mov eax, [window]
 000005D7  0F B7 04 01		        movzx   eax, word ptr [eax + ecx]
 000005DB  3B 44 24 10		        cmp eax, [scanstart]
 000005DF  75 CF		        jnz LookupLoop

				;;; Store the current value of chainlen.

 000005E1  89 14 24		        mov [chainlenwmask], edx

				;;; Point edi to the string under scrutiny, and esi to the string we
				;;; are hoping to match it up with. In actuality, esi and edi are
				;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is
				;;; initialized to -(MAX_MATCH_8 - scanalign).

 000005E4  8B 74 24 04		        mov esi, [window]
 000005E8  8B 7C 24 20		        mov edi, [scan]
 000005EC  03 F1		        add esi, ecx
 000005EE  8B 44 24 14		        mov eax, [scanalign]
 000005F2  BA FFFFFEF8		        mov edx, 0fffffef8h; -(MAX_MATCH_8)
 000005F7  8D BC 38		        lea edi, [edi + eax + 0108h] ;MAX_MATCH_8]
	   00000108
 000005FE  8D B4 30		        lea esi, [esi + eax + 0108h] ;MAX_MATCH_8]
	   00000108

				;;; Test the strings for equality, 8 bytes at a time. At the end,
				;;; adjust edx so that it is offset to the exact byte that mismatched.
				;;;
				;;; We already know at this point that the first three bytes of the
				;;; strings match each other, and they can be safely passed over before
				;;; starting the compare loop. So what this code does is skip over 0-3
				;;; bytes, as much as necessary in order to dword-align the edi
				;;; pointer. (esi will still be misaligned three times out of four.)
				;;;
				;;; It should be confessed that this loop usually does not represent
				;;; much of the total running time. Replacing it with a more
				;;; straightforward "rep cmpsb" would not drastically degrade
				;;; performance.

 00000605			LoopCmps:
 00000605  8B 04 32		        mov eax, [esi + edx]
 00000608  33 04 3A		        xor eax, [edi + edx]
 0000060B  75 14		        jnz LeaveLoopCmps
 0000060D  8B 44 32 04		        mov eax, [esi + edx + 4]
 00000611  33 44 3A 04		        xor eax, [edi + edx + 4]
 00000615  75 07		        jnz LeaveLoopCmps4
 00000617  83 C2 08		        add edx, 8
 0000061A  75 E9		        jnz LoopCmps
 0000061C  EB 71		        jmp short LenMaximum
 0000061E  83 C2 04		LeaveLoopCmps4: add edx, 4
 00000621  A9 0000FFFF		LeaveLoopCmps:  test    eax, 0000FFFFh
 00000626  75 06		        jnz LenLower
 00000628  83 C2 02		        add edx,  2
 0000062B  C1 E8 10		        shr eax, 16
 0000062E  2C 01		LenLower:   sub al, 1
 00000630  83 D2 00		        adc edx, 0

				;;; Calculate the length of the match. If it is longer than MAX_MATCH,
				;;; then automatically accept it as the best possible match and leave.

 00000633  8D 04 3A		        lea eax, [edi + edx]
 00000636  8B 7C 24 20		        mov edi, [scan]
 0000063A  2B C7		        sub eax, edi
 0000063C  3D 00000102		        cmp eax, MAX_MATCH
 00000641  7D 4C		        jge LenMaximum

				;;; If the length of the match is not longer than the best match we
				;;; have so far, then forget it and return to the lookup loop.

 00000643  8B 54 24 38		        mov edx, [deflatestate]
 00000647  8B 5C 24 1C		        mov ebx, [bestlen]
 0000064B  3B C3		        cmp eax, ebx
 0000064D  7F 13		        jg  LongerMatch
 0000064F  8B 74 24 08		        mov esi, [windowbestlen]
 00000653  8B 7A 40		        mov edi, [edx + dsPrev]
 00000656  8B 5C 24 0C		        mov ebx, [scanend]
 0000065A  8B 14 24		        mov edx, [chainlenwmask]
 0000065D  E9 FFFFFF4E		        jmp LookupLoop

				;;;         s->match_start = cur_match;
				;;;         best_len = len;
				;;;         if (len >= nice_match) break;
				;;;         scan_end = *(ushf*)(scan+best_len-1);

 00000662  8B 5C 24 18		LongerMatch:    mov ebx, [nicematch]
 00000666  89 44 24 1C		        mov [bestlen], eax
 0000066A  89 4A 70		        mov [edx + dsMatchStart], ecx
 0000066D  3B C3		        cmp eax, ebx
 0000066F  7D 2D		        jge LeaveNow
 00000671  8B 74 24 04		        mov esi, [window]
 00000675  03 F0		        add esi, eax
 00000677  89 74 24 08		        mov [windowbestlen], esi
 0000067B  0F B7 5C 38 FF	        movzx   ebx, word ptr [edi + eax - 1]
 00000680  8B 7A 40		        mov edi, [edx + dsPrev]
 00000683  89 5C 24 0C		        mov [scanend], ebx
 00000687  8B 14 24		        mov edx, [chainlenwmask]
 0000068A  E9 FFFFFF21		        jmp LookupLoop

				;;; Accept the current string, with the maximum possible length.

 0000068F  8B 54 24 38		LenMaximum: mov edx, [deflatestate]
 00000693  C7 44 24 1C		        mov dword ptr [bestlen], MAX_MATCH
	   00000102
 0000069B  89 4A 70		        mov [edx + dsMatchStart], ecx

				;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
				;;; return s->lookahead;

 0000069E			LeaveNow:
 0000069E  8B 54 24 38		        mov edx, [deflatestate]
 000006A2  8B 5C 24 1C		        mov ebx, [bestlen]
 000006A6  8B 42 74		        mov eax, [edx + dsLookahead]
 000006A9  3B D8		        cmp ebx, eax
 000006AB  7F 02		        jg  LookaheadRet
 000006AD  8B C3		        mov eax, ebx
 000006AF			LookaheadRet:

				;;; Restore the stack and return from whence we came.

 000006AF  83 C4 24		        add esp, LocalVarsSize
 000006B2  5B			        pop ebx
 000006B3  5E			        pop esi
 000006B4  5F			        pop edi
 000006B5  5D			        pop ebp

 000006B6  C3			        ret
				; please don't remove this string !
				; Your can freely use gvmat32 in any free or commercial app if you don't remove the string in the binary!
 000006B7  0D 0A 61 73 6D	    db     0dh,0ah,"asm686 with masm, optimised assembly code from Brian Raiter, written 1998",0dh,0ah
	   36 38 36 20 77
	   69 74 68 20 6D
	   61 73 6D 2C 20
	   6F 70 74 69 6D
	   69 73 65 64 20
	   61 73 73 65 6D
	   62 6C 79 20 63
	   6F 64 65 20 66
	   72 6F 6D 20 42
	   72 69 61 6E 20
	   52 61 69 74 65
	   72 2C 20 77 72
	   69 74 74 65 6E
	   20 31 39 39 38
	   0D 0A


				IFDEF NOOLDPENTIUMCODE
				ELSE
				    IFDEF NOUNDERLINE
				    ELSE
 00000704			    _longest_match_686  endp
				    ENDIF
				ENDIF

 00000704			_TEXT   ends
				end
Microsoft (R) Macro Assembler Version 6.14.8444		    12/27/09 07:12:50
gvmat32.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

maccn  . . . . . . . . . . . . .	Proc
normbeg  . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	32 Bit	 00000000 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000704 DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

_cpudetect32 . . . . . . . . . .	P Near	 000004E1 _TEXT	Length= 0000003E Public
  exitcpudetect  . . . . . . . .	L Near	 0000050F _TEXT	
  end_cpu_is_386 . . . . . . . .	L Near	 00000511 _TEXT	
  is_old_486 . . . . . . . . . .	L Near	 00000518 _TEXT	
_longest_match_686 . . . . . . .	P Near	 0000051F _TEXT	Length= 000001E5 Public
  LastMatchGood  . . . . . . . .	L Near	 00000544 _TEXT	
  LookaheadLess  . . . . . . . .	L Near	 0000055C _TEXT	
  LimitPositive  . . . . . . . .	L Near	 0000058B _TEXT	
  LookupLoop . . . . . . . . . .	L Near	 000005B0 _TEXT	
  LoopEntry  . . . . . . . . . .	L Near	 000005CA _TEXT	
  LoopCmps . . . . . . . . . . .	L Near	 00000605 _TEXT	
  LeaveLoopCmps4 . . . . . . . .	L Near	 0000061E _TEXT	
  LeaveLoopCmps  . . . . . . . .	L Near	 00000621 _TEXT	
  LenLower . . . . . . . . . . .	L Near	 0000062E _TEXT	
  LongerMatch  . . . . . . . . .	L Near	 00000662 _TEXT	
  LenMaximum . . . . . . . . . .	L Near	 0000068F _TEXT	
  LeaveNow . . . . . . . . . . .	L Near	 0000069E _TEXT	
  LookaheadRet . . . . . . . . .	L Near	 000006AF _TEXT	
_longest_match_7fff  . . . . . .	P Near	 00000000 _TEXT	Length= 000004E1 Public
  noshr  . . . . . . . . . . . .	L Near	 0000001E _TEXT	
  nolookaheadnicematch . . . . .	L Near	 00000032 _TEXT	
  nodist . . . . . . . . . . . .	L Near	 0000006F _TEXT	
  normalbeg0add16  . . . . . . .	L Near	 000000A0 _TEXT	
  normalbeg0 . . . . . . . . . .	L Near	 000000AB _TEXT	
  rcontlabnoroll . . . . . . . .	L Near	 000000B1 _TEXT	
  normalbeg2noroll . . . . . . .	L Near	 000000CD _TEXT	
  contloop3  . . . . . . . . . .	L Near	 000000D8 _TEXT	
  jnbexitloopshort1  . . . . . .	L Near	 000000E7 _TEXT	
  beginloop2 . . . . . . . . . .	L Near	 000000ED _TEXT	
  do16 . . . . . . . . . . . . .	L Near	 000000F4 _TEXT	
  rcontloop0 . . . . . . . . . .	L Near	 000000FE _TEXT	
  rcontloop1 . . . . . . . . . .	L Near	 00000119 _TEXT	
  rcontloop2 . . . . . . . . . .	L Near	 00000134 _TEXT	
  rcontloop3 . . . . . . . . . .	L Near	 0000014F _TEXT	
  rcontloop4 . . . . . . . . . .	L Near	 0000016A _TEXT	
  rcontloop5 . . . . . . . . . .	L Near	 00000185 _TEXT	
  rcontloop6 . . . . . . . . . .	L Near	 000001A0 _TEXT	
  rcontloop7 . . . . . . . . . .	L Near	 000001BB _TEXT	
  rcontloop8 . . . . . . . . . .	L Near	 000001D6 _TEXT	
  rcontloop9 . . . . . . . . . .	L Near	 000001F1 _TEXT	
  rcontloop10  . . . . . . . . .	L Near	 0000020C _TEXT	
  rcontloop11  . . . . . . . . .	L Near	 00000223 _TEXT	
  rcontloop12  . . . . . . . . .	L Near	 0000023A _TEXT	
  rcontloop13  . . . . . . . . .	L Near	 00000251 _TEXT	
  rcontloop14  . . . . . . . . .	L Near	 00000268 _TEXT	
  rcontloop15  . . . . . . . . .	L Near	 0000027F _TEXT	
  normalbeg2dc11 . . . . . . . .	L Near	 000002A0 _TEXT	
  normalbeg2dc12 . . . . . . . .	L Near	 000002B4 _TEXT	
  normalbeg2dc13 . . . . . . . .	L Near	 000002C4 _TEXT	
  normalbeg2dc14 . . . . . . . .	L Near	 000002D4 _TEXT	
  normalbeg2dc15 . . . . . . . .	L Near	 000002E4 _TEXT	
  normalbeg2dc10 . . . . . . . .	L Near	 000002F4 _TEXT	
  normalbeg2dc9  . . . . . . . .	L Near	 00000308 _TEXT	
  normalbeg2dc8  . . . . . . . .	L Near	 0000031C _TEXT	
  normalbeg2dc7  . . . . . . . .	L Near	 00000330 _TEXT	
  normalbeg2dc6  . . . . . . . .	L Near	 00000344 _TEXT	
  normalbeg2dc5  . . . . . . . .	L Near	 00000355 _TEXT	
  normalbeg2dc4  . . . . . . . .	L Near	 00000366 _TEXT	
  normalbeg2dc3  . . . . . . . .	L Near	 00000377 _TEXT	
  normalbeg2dc2  . . . . . . . .	L Near	 00000388 _TEXT	
  normalbeg2dc1  . . . . . . . .	L Near	 00000399 _TEXT	
  normalbeg2dc0  . . . . . . . .	L Near	 000003AA _TEXT	
  normalbeg2 . . . . . . . . . .	L Near	 000003BB _TEXT	
  iseq . . . . . . . . . . . . .	L Near	 000003C9 _TEXT	
  eq1rr  . . . . . . . . . . . .	L Near	 000003E4 _TEXT	
  eq1  . . . . . . . . . . . . .	L Near	 000003F0 _TEXT	
  eq11 . . . . . . . . . . . . .	L Near	 000003FF _TEXT	
  begincompare . . . . . . . . .	L Near	 00000406 _TEXT	
  trfin  . . . . . . . . . . . .	L Near	 00000431 _TEXT	
  trfinval . . . . . . . . . . .	L Near	 00000435 _TEXT	
  newbestlen . . . . . . . . . .	L Near	 0000044C _TEXT	
  exitloop . . . . . . . . . . .	L Near	 0000047C _TEXT	
  minexlo  . . . . . . . . . . .	L Near	 00000494 _TEXT	
  InfoAuthor . . . . . . . . . .	L Near	 0000049C _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
LocalVarsSize  . . . . . . . . .	Number	 00000024h   
MAX_MATCH_8_ . . . . . . . . . .	Number	 00000100h   
MAX_MATCH  . . . . . . . . . . .	Number	 00000102h   
MIN_LOOKAHEAD  . . . . . . . . .	Number	 00000106h   
MIN_MATCH  . . . . . . . . . . .	Number	 00000003h   
NbStackAdd . . . . . . . . . . .	Number	 00000034h   
NbStack  . . . . . . . . . . . .	Number	 0000004Ch   
adrret . . . . . . . . . . . . .	Text   	 dword ptr[esp+NbStack-8]
best_len . . . . . . . . . . . .	Text   	 dword ptr [esp+NbStack-36]
bestlen  . . . . . . . . . . . .	Text   	 esp + 28
chain_length . . . . . . . . . .	Text   	 dword ptr [esp+NbStack-28]
chainlenwmask  . . . . . . . . .	Text   	 esp + 0
cur_match  . . . . . . . . . . .	Text   	 dword ptr[esp+NbStack-0]
curmatch . . . . . . . . . . . .	Text   	 esp + 60
deflatestate . . . . . . . . . .	Text   	 esp + 56
dep_chain_length . . . . . . . .	Number	 0000007Ch   
dep_good_match . . . . . . . . .	Number	 0000008Ch   
dep_lookahead  . . . . . . . . .	Number	 00000074h   
dep_match_start  . . . . . . . .	Number	 00000070h   
dep_nice_match . . . . . . . . .	Number	 00000090h   
dep_prev_length  . . . . . . . .	Number	 00000078h   
dep_prev . . . . . . . . . . . .	Number	 00000040h   
dep_strstart . . . . . . . . . .	Number	 0000006Ch   
dep_w_mask . . . . . . . . . . .	Number	 00000034h   
dep_w_size . . . . . . . . . . .	Number	 0000002Ch   
dep_window . . . . . . . . . . .	Number	 00000038h   
dsGoodMatch  . . . . . . . . . .	Number	 0000008Ch   
dsLookahead  . . . . . . . . . .	Number	 00000074h   
dsMatchLen . . . . . . . . . . .	Number	 00000060h   
dsMatchStart . . . . . . . . . .	Number	 00000070h   
dsMaxChainLen  . . . . . . . . .	Number	 0000007Ch   
dsNiceMatch  . . . . . . . . . .	Number	 00000090h   
dsPrevLen  . . . . . . . . . . .	Number	 00000078h   
dsPrevMatch  . . . . . . . . . .	Number	 00000064h   
dsPrev . . . . . . . . . . . . .	Number	 00000040h   
dsStrStart . . . . . . . . . . .	Number	 0000006Ch   
dsWMask  . . . . . . . . . . . .	Number	 00000034h   
dsWSize  . . . . . . . . . . . .	Number	 0000002Ch   
dsWindow . . . . . . . . . . . .	Number	 00000038h   
limit  . . . . . . . . . . . . .	Text   	 dword ptr [esp+NbStack-32]
match_start_ptr  . . . . . . . .	Text   	 dword ptr [esp+NbStack-56]
match_start  . . . . . . . . . .	Text   	 dword ptr [esp+NbStack-72]
nice_match . . . . . . . . . . .	Text   	 dword ptr [esp+NbStack-60]
nicematch  . . . . . . . . . . .	Text   	 esp + 24
prev . . . . . . . . . . . . . .	Text   	 dword ptr [esp+NbStack-44]
pushebp  . . . . . . . . . . . .	Text   	 dword ptr[esp+NbStack-12]
pushebx  . . . . . . . . . . . .	Text   	 dword ptr[esp+NbStack-24]
pushedi  . . . . . . . . . . . .	Text   	 dword ptr[esp+NbStack-16]
pushesi  . . . . . . . . . . . .	Text   	 dword ptr[esp+NbStack-20]
scan_start . . . . . . . . . . .	Text   	 word ptr [esp+NbStack-48]
scanalign  . . . . . . . . . . .	Text   	 esp + 20
scanend  . . . . . . . . . . . .	Text   	 esp + 12
scanstart  . . . . . . . . . . .	Text   	 esp + 16
scan . . . . . . . . . . . . . .	Text   	 esp + 32
str_s  . . . . . . . . . . . . .	Text   	 dword ptr[esp+NbStack-4]
strend . . . . . . . . . . . . .	Text   	 dword ptr [esp+NbStack-76]
windowbestlen  . . . . . . . . .	Text   	 esp + 8
windowlen  . . . . . . . . . . .	Text   	 dword ptr [esp+NbStack-68]
window . . . . . . . . . . . . .	Text   	 esp + 4
wmask  . . . . . . . . . . . . .	Text   	 dword ptr [esp+NbStack-52]
zlib1222add  . . . . . . . . . .	Number	 00000008h   

	   0 Warnings
	   0 Errors
